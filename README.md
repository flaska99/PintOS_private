# 🧠 PintOS - Operating System Implementation

> **카네기 멜론 대학 운영체제 프로젝트**: 스레드 관리부터 가상 메모리까지 완전한 OS 구현

## 📋 프로젝트 개요

PintOS는 카네기 멜론 대학의 CS:APP 교육용 운영체제로, 실제 동작하는 OS의 핵심 기능들을 단계적으로 구현하는 프로젝트입니다. 세 개의 주요 프로젝트를 통해 운영체제의 핵심 개념들을 학습하고 구현했습니다.

### 🛠️ 개발 환경
- **플랫폼**: x86-64 기반 Ubuntu 18.04 (Docker 환경)
- **에뮬레이터**: QEMU
- **디버깅**: GDB
- **언어**: C
- **아키텍처**: 64비트 지원 KAIST-PintOS

---

## 🧵 Project 1: Threads - 스레드 및 동기화

### 📌 구현한 핵심 기능

#### 1. ⏰ Alarm Clock (timer_sleep)
**해결한 문제**: 기존 busy waiting 방식의 CPU 자원 낭비

**구현 방식**:
- `sleep_list`를 활용한 효율적 대기 시스템 구축
- `wakeup_tick` 기준으로 정렬된 리스트 관리
- `timer_interrupt`에서 일괄 깨우기 처리

**성과**: CPU 사용률 대폭 감소, 시스템 응답성 향상

#### 2. 🎯 Priority Scheduling
**구현 내용**:
- Ready queue 우선순위 기반 정렬
- 새 스레드 생성 시 선점 스케줄링
- 조건부 `thread_yield`로 불필요한 컨텍스트 스위칭 방지

#### 3. 🔄 Priority Donation
**핵심 개념**: Priority Inversion 방지 메커니즘

**구현 특징**:
- 다중 donation 및 중첩 donation 지원
- Lock 해제 시 우선순위 복원
- 재귀적 우선순위 전파

#### 4. 📊 Advanced Scheduler (4.4BSD)
- Multi-level feedback queue 구현
- Load average와 recent_cpu 동적 계산
- Nice value 기반 우선순위 조정

### 🔧 주요 트러블 슈팅 경험

#### 문제 1: 세마포어 waiter_list 우선순위 정렬 실패
- **현상**: Priority-Sema 테스트 실패
- **분석**: waiter_list에서 우선순위 미정렬
- **해결**: `list_insert_ordered()` 적용

#### 문제 2: Priority Donation 전파 실패
- **현상**: 중첩 락에서 우선순위 전파 안됨
- **분석**: 재귀적 전파 로직 부재
- **해결**: `wait_on_lock` 체인을 따라 우선순위 전파

#### 문제 3: Race Condition 발생
- **현상**: 임계영역에서 데이터 불일치
- **분석**: 인터럽트 보호 미흡
- **해결**: 명확한 임계영역 설정 및 인터럽트 제어

### 📈 학습 성과
- **스레드 라이프사이클** 완전 이해
- **동기화 메커니즘** (세마포어, 락, 조건변수) 구현 경험
- **우선순위 스케줄링** 알고리즘 실무 적용
- **디버깅 기술** 향상 (GDB 활용한 커널 디버깅)

---

## 💾 Project 2: User Programs - 시스템 콜 및 프로세스 관리

### 📌 구현한 핵심 기능

#### 1. 🔧 시스템 콜 (System Call)
**구현한 시스템 콜들**:
- **파일 관리**: `open`, `close`, `read`, `write`, `create`, `remove`
- **프로세스 제어**: `exec`, `wait`, `exit`
- **메모리 관리**: `mmap`, `munmap`

**시스템 콜 처리 흐름**:
```
사용자 모드 → Trap 발생 → 커널 모드 전환 → syscall_handler → 각 시스템 콜 함수 → 결과 반환
```

#### 2. 📄 Argument Passing
**해결한 문제**: 명령줄 인자를 사용자 프로그램에 전달

**구현 방식**:
- 스택에 인자들을 역순으로 push
- 포인터 배열 생성 및 정렬
- argc, argv 설정

#### 3. 🔐 User Memory Access 보호
**보안 메커니즘**:
- 사용자 포인터 유효성 검증
- 커널 영역 접근 차단
- Page fault 기반 예외 처리

#### 4. 📁 File System 동기화
**구현 내용**:
- 파일 디스크립터 테이블 관리
- 실행 중인 파일 쓰기 금지
- 전역 락을 통한 파일 시스템 동기화

### 🔧 주요 트러블 슈팅 경험

#### 문제 1: 메모리 풀 초기화 오류
- **현상**: `supplemental_page_table_init` 호출 시 커널 패닉
- **분석**: 구조체 내부 요소 초기화 누락
- **해결**: 동적 할당을 통한 구조체 멤버 초기화

#### 문제 2: SPT find_page 무한 루프
- **현상**: `spt_find_page`에서 계속된 페이지 폴트
- **분석**: NULL 포인터 체크 부재
- **해결**: 예외 처리 로직 추가

#### 문제 3: User Buffer 검증 오류
- **현상**: 지연 로딩 방식에서 검증 실패
- **분석**: `pml4_get_page` 로직이 지연 로딩과 호환되지 않음
- **해결**: 검증 로직을 지연 로딩 방식에 맞게 수정

### 💡 핵심 개념 학습

#### 메모리 풀 (Memory Pool)
- **개념**: 미리 확보한 자원의 집합
- **장점**: 할당/해제 비용 절감, 단편화 방지, 시간 예측 가능성
- **구현**: Palloc (페이지 할당기)을 통한 4KB 단위 관리

#### MMU와 PML4
- **PML4**: x86-64 아키텍처의 4단계 페이지 테이블 최상위
- **가상 주소 변환**: 48비트 가상 주소를 4단계로 분할하여 물리 주소 매핑
- **페이지 테이블 워킹**: PML4 → PDPT → PD → PT → 물리 페이지

### 📈 학습 성과
- **시스템 콜 메커니즘** 완전 이해
- **프로세스 생명주기** 관리 경험
- **메모리 관리 시스템** 깊이 있는 학습
- **보안 메커니즘** 구현 경험

---

## 🗄️ Project 3: Virtual Memory - 가상 메모리 관리

### 📌 구현한 핵심 기능

#### 1. 📊 Supplemental Page Table (SPT)
**역할**: 가상 메모리 관리를 위한 부가 정보 저장

**PML4 vs SPT 비교**:
| 항목 | PML4 (페이지 테이블) | SPT (보조 페이지 테이블) |
|------|---------------------|------------------------|
| 역할 | 가상 주소 → 물리 주소 변환 | Lazy load, swap 등 부가 정보 저장 |
| 접근 주체 | 하드웨어(CPU MMU) | 커널 (PintOS OS) |
| 자료구조 | 4단계 테이블 | Hash Table |
| 저장 정보 | 주소 매핑 | struct page 등 상세 정보 |

#### 2. 🔄 Lazy Loading
**구현 방식**:
- 페이지 폴트 발생 시 실제 로딩 수행
- `vm_try_handle_fault`에서 페이지 타입별 처리
- Uninit → File/Anon 페이지로 변환

#### 3. 📚 Stack Growth
**동적 스택 확장 구현**:
- 스택 접근 시 자동 확장
- 1MB 제한 내에서 페이지 단위 할당
- `stack_bottom` 추적을 통한 효율적 관리

#### 4. 🔀 Memory Mapped Files (mmap)
**구현 내용**:
- 파일을 가상 메모리에 매핑
- Lazy loading을 통한 효율적 메모리 사용
- 수정된 페이지의 파일 동기화

### 🔧 주요 트러블 슈팅 경험

#### 문제 1: SPT Copy 실패 (Fork 구현)
**1차 시도 - 단순 memcpy**:
- **문제**: 물리 메모리 공유로 인한 무결성 위반
- **분석**: 부모-자식 프로세스가 같은 frame 공유

**2차 시도 - 타입별 처리**:
- **UNINIT 페이지**: 부모 페이지 정보 그대로 복사
- **ANON 페이지**: 새 frame 할당 후 내용 복사
- **문제**: frame이 NULL인 경우 처리 미흡

**최종 해결**:
- NULL frame 예외 처리 추가
- 타입별 적절한 복사 전략 수립

#### 문제 2: User Buffer 검증 오류
**현상**: 지연 로딩 환경에서 검증 로직 실패
**해결**: `pml4_get_page` 의존성 제거, 커널 주소 검증으로 단순화

### 💡 핵심 개념 학습

#### 가상 주소 공간 구조
```
높은 주소 (High address)
┌────────────────────────────┐
│ Stack                      │ ← USER_STACK
├────────────────────────────┤
│ mmap 영역                  │ ← mmap() 매핑
├────────────────────────────┤
│ Heap                       │ ← malloc/new 동적 할당
├────────────────────────────┤
│ BSS Segment                │ ← 초기화되지 않은 전역 변수
├────────────────────────────┤
│ Data Segment               │ ← 초기화된 전역 변수
├────────────────────────────┤
│ Code Segment (Text)        │ ← 프로그램 실행 코드
└────────────────────────────┘
낮은 주소 (Low address)
```

#### 페이지 폴트 처리 흐름
```
유저 프로세스 메모리 접근 → 페이지 폴트 발생 → SPT에서 페이지 정보 조회 
→ 페이지 타입별 처리 → 물리 메모리 할당 → PML4에 매핑 추가 → 재시도 성공
```

### 📈 학습 성과
- **가상 메모리 시스템** 완전한 이해
- **페이지 폴트 핸들링** 구현 경험
- **메모리 매핑** 메커니즘 학습
- **복잡한 시스템 디버깅** 능력 향상

---

## 🎯 전체 프로젝트 성과 및 학습

### 🏆 기술적 성취

#### 운영체제 핵심 기능 구현
- **스레드 스케줄링**: Priority donation, MLFQS 등 고급 스케줄링 알고리즘
- **시스템 콜**: 완전한 사용자-커널 인터페이스 구현
- **가상 메모리**: 지연 로딩, mmap, 스택 확장 등 고급 메모리 관리

#### 동시성 및 동기화
- **Race Condition 해결**: 임계영역 보호, 인터럽트 제어
- **데드락 방지**: Priority donation을 통한 priority inversion 해결
- **효율적 동기화**: 세마포어, 락, 조건변수 활용

#### 메모리 관리 전문성
- **물리 메모리 관리**: Palloc을 통한 페이지 할당
- **가상 메모리 설계**: SPT와 PML4의 이중 구조 이해
- **메모리 보호**: 사용자-커널 경계 보안 메커니즘

### 🛠️ 문제 해결 능력

#### 체계적 디버깅 접근
1. **로그 분석**: Backtrace를 통한 오류 지점 추적
2. **GDB 활용**: 메모리 상태 검사, 단계별 실행
3. **가설-검증**: 문제 원인 가설 수립 후 코드 수정으로 검증

#### 복잡한 시스템 이해
- **멀티레벨 구조**: 하드웨어-커널-사용자 계층 상호작용
- **비동기 처리**: 인터럽트, 페이지 폴트 등 예외 상황 처리
- **자원 관리**: 메모리, 파일, 프로세스 등 시스템 자원 효율적 관리

### 📚 학습한 이론

#### 운영체제 이론
- **프로세스 vs 스레드**: 생명주기, 메모리 공유, 컨텍스트 스위칭
- **스케줄링 알고리즘**: FCFS, Priority, MLFQS 비교 분석
- **메모리 계층**: 물리-가상 메모리, 페이징, 세그멘테이션

#### 시스템 프로그래밍
- **저수준 프로그래밍**: 포인터 조작, 메모리 직접 접근
- **하드웨어 인터페이스**: MMU, 인터럽트 컨트롤러 활용
- **성능 최적화**: 캐시 효율성, 메모리 사용량 최적화

---

**팀 구성**: 3인 팀으로 진행  
**코드 라인 수**: 약 3,000+ lines  
**테스트 통과율**: 100% (모든 테스트 케이스 통과)

> 이 프로젝트를 통해 운영체제의 내부 동작 원리를 깊이 이해하고, 복잡한 시스템을 설계하고 구현하는 능력을 크게 향상시킬 수 있었습니다. 특히 멀티스레딩 환경에서의 동기화 문제와 가상 메모리 관리는 실무에서도 직접 활용할 수 있는 귀중한 경험이었습니다.
